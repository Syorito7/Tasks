\documentclass[a4paper, 12pt]{report}

\usepackage[utf8]{inputenc}

\usepackage{amsmath,amsthm,amssymb}
\usepackage{mathtext}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,bulgarian,ukrainian,russian]{babel}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{tabto}
\usepackage{hyperref}


\setlength{\parskip}{1em}
\lstset{language=Python}


\begin{document}
\thispagestyle{empty}

\begin{center}
    \textbf{Федеральное государственное автономное образовательное \\
    учреждение высшего \\
    образования\\
    "Национальный исследовательский университет \\
    "Высшая школа экономики" \\}
    \bigskip
    \bigskip
    \bigskip
    \bigskip
    Образовательная программа "Прикладная математика" \\
    бакалавр \\
    \bigskip
    \bigskip
    \bigskip
    \bigskip
    \textbf{\largeОТЧЕТ \\}
    \normalfont \textbf{по проектной работе \\ }
    \bigskip
    \bigskip
    \large \textbf{Распознавание протоколов}
    \bigskip
    \bigskip
    \bigskip
    \bigskip
    \bigskip
    \bigskip
\end{center}

\begin{flushright}
    \textbf{Выполнили студенты гр.БПМ-211}\\
    \bigskip
    Кармаев Александр Андреевич\\
    Родин Сергей Алексеевич \\
    Индюченко Никита Андреевич\\
    \bigskip
\end{flushright}

\begin{flushleft}
    \textbf{Руководитель проекта:}\\
    \bigskip
    Доцент \\
    \bigskip
    Сластников Сергей Александрович \\
    \begin{tabular}{c}
    \\ \hline
    (оценка)
    \end{tabular}\ \ \ 
    \begin{tabular}{c}
    \\ \hline
    (подпись)
    \end{tabular}\\
    \begin{tabular}{c}
    \\ \hline
    (дата)
    \end{tabular}
\end{flushleft}

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip

    
\begin{center}
    Москва - 2022
\end{center}
\pagebreak

\tableofcontents

\chapter{Введение}
В настоящее время все больше используются электронные системы хранения данных. Но многие организации все еще используют консервативные методы хранения информации на бумажных носителях. Благодаря современным технологиям стало возможно конвертировать печатные и рукописные документы в электронный формат. Обеспечение системами распознавания табличных данных позволяет значительно оптимизировать процесс работы и избавить сотрудников от ручного переноса данных с бумажных носителей на электронные.

\section{Цель работы}
Разработка и тестирование программы по переводу рукописно заполненных таблиц с протоколами различных соревнований в excel таблицу.

\section{Предмет исследования}
Различные инструменты распознавания образов и детектирования содержимого определенного вида печатных и рукописных документов на основе технологий Computer Vision.

\section{Задачи}
\begin{itemize}
  \item Изучить технологии распознавания объектов, текста для обработки документов, выбрать наиболее подходящие для нашей цели инструменты
  \item Разработать алгоритмы обнаружения и распознавания таблицы в протоколе, используя выбранные выше технологии
  \item Протестировать полученные решения на разных типах входных данных для получения метрик точности распознавания
\end{itemize}

\section{Планируемые результаты}
\begin{itemize}
  \item Реализация различных алгоритмов решения задачи и выявление наиболее эффективного способа считывания документов 
  \item Сравнение результатов работы программы с печатными и с рукописными данными
  \item Определение наиболее подходящих параметров исходных изображений и настроек программы для улучшения распознавания 
\end{itemize}

\chapter{Теоретический материал}

\section{Что такое OCR}

OCR (Optical character recognition) – это программа для перевода изображений печатного или рукописного текста в текстовые данные. Она используется при работе с отсканированными документами.

Технология OCR способна экспортировать формат и размер текста. Она применяется для преобразования копий документов в любой популярный электронный формат. 

Например, при сканировании больших многостраничных документов в цифровое изображение OCR программа преобразует документ в редактируемый файл.

Для распознавания протоколов мы воспользовались языком программирования Python. Также мы рассмотрели возможности технологии OCR, которые совместимые с нашим инструментом – PyTesseract.

Мы использовали библиотеку Python-Tesseract, которая является оболочкой для Google Tesseract-OCR Engine.

\section{Что такое нейронные сети}
Основной замысел нейронной сети заключается в том, чтобы спроектировать множество объединённых между собой "клеток мозга" в глубине вычислительной машины для реализации возможности научить ее угадывать, анализировать вещи, законы и следовательно действовать по-человечески. Особенностью “мозга” компьютера является то, что ему не нужно задавать определённые шаги, действия, то есть программирование не является объектом обучения. Он сам освоится, как человеческий мозг.

Мы выделили два основных вида  нейронных сетей, первый – рекуррентный, а второй – сверточный. Он абсолютно подходит для наших целей, то есть обработки изображения, в отличии от первого, который хорошо распознаёт тексты, потому что наши данные – это печатные или рукописные файлы.


\subsection{TensorFlow}
TensorFlow – открытая библиотека, созданная Google для численных вычислений. Написана на Python и C++ и признана на рынке одним из лучших фреймворков. TensorFlow отлично подходит для сложных проектов, таких как создание нейронных сетей. На ее основе можно создавать программы распознавания голоса и изображений.

Достоинства TensorFlow:
\begin{itemize}
  \item Множество ресурсов и интернете, большая документация
  \item Наличие TensorBoard – средство отслеживания процесса обучения и визуализации результатов
  \item Поддержка распределенного обучения
  \item Популярна среди разработчиков, используется во многих технических компаниях
  \item Поддержка обслуживания моделей
  \item Использование различных мощностей компьютера (GPU, поддерживающие технологию CUDA, СPU и TPU)
\end{itemize}

Недостатки TensorFlow:
\begin{itemize}
  \item Высокий порог вхождения для начинающих разработчиков. Фреймворк является весьма низкоуровневым, требует много изначально подготовленного кода, сложный процесс отладки
  \item Python является единственным языком, на который поддерживает TensorFlow
\end{itemize}

\subsection{CUDA}
CUDA – Это программная технология, которая позволяет параллельно распределить вычисления графического процессора, произведённые фирмой Nvidia. Функции, ускоренные при помощи CUDA, можно вызывать из различных языков, в том числе Python.

Для полной поддержки технологии CUDA, которую мы хотим использовать для обучения нашей модели, необходимо:

\begin{enumerate}
  \item Наличие видеокарты Nvidia, которая поддерживает CUDA. В нашем случае – это видеокарта GTX1650
  \item Поколение видеокарты должно быть не старее Kepler – у нас Pascal
  \item Обновить драйвер до последней версии (выше 410.0). В нашем случае установлена версия 516.01
  \item В зависимости от версии драйвера установить соответствующую версию СUDA. Для нас актуальна версия 11.7
  \item Установить соответствующую версию СUDA Toolkit, которая связана с CUDA и версией драйвера вашей видеокарты
  \item Установить и настроить библиотеку сuDNN, которая также связана с версией CUDA
\end{enumerate}

\pagebreak
\subsection{TPU и Colaboratory}
TPU – тензорный процессор, принадлежит к виду нейронных процессоров. Создан корпорацией Google для применения вместе с библиотекой TensorFlow. Представляет собой нейронный, который является интегральной схемой, содержит 4 чипа, по 2 ядра. На каждом ядре выполняется копия графа TF, обучение происходит параллельно на всех ядрах при использовании репликации.

Colaboratory – облачная система, подобная jupyter notebook, где можно создавать блокноты для написания и выполнения кода, созданная Google для разработок в области машинного обучения.

Для работы выделяется виртуальная машина, с предустановленными библиотеками, такими как TensorFlow и Keras для обучения собственных моделей.

Именно поэтому в командной работе мы воспользуемся Colaboratory, так как помимо удобности в реализации проекта, большим плюсом являются мощности серверов. Наша система позволяет воспользоваться всего лишь 6 TFlops. То есть облачный сервис способен в 30 раз быстрее обучить нашу нейронную сеть, чем настольный компьютер. Однако есть и свои минусы:

\begin{enumerate}
  \item Данные нужно хранить на Google Drive, так как виртуальная машина предоставляется на протяжении 12 часов, после чего все данные удаляются. Однако, ничто не мешает запустить ещё одну виртуальную машину
  \item Потери производительности могут быть связаны из-за низкой скорости интернета, которая связывает ПК и сервером, то есть является bottleneck’ом (узким местом нашей цепочки)
\end{enumerate}

\pagebreak
\subsection{Keras}
Keras – это вспомогательная библиотека, написанная на Python, которая запускается поверх TensoFlow и других библиотек ML. Была разработана компанией Google для ускорения проведения различных экспериментов.
Keras поддерживает множество слоёв нейронных сетей, например, сверточных, тех которые использовались нами в программе. Фреймворк весьма хорош в задачах для работы с речью, текстами, изображениями и т.д. 

Преимущества:
\begin{itemize}
  \item Удобен и прост в изучении
  \item Достаточно мало весит для построения сложных моделей глубокого обучения
  \item Эффективное прототипирование
  \item Может обучаться на нескольких GPU
  \item Модули полностью конфигурируемы
  \item Поддержка TPU от Google, GPU от NVIDIA и Open-CL
\end{itemize}

Недостатки:
\begin{itemize}
  \item Не всегда легко кастомизировать
  \item Ограничен бэкэндами CNTK, Tensorflow и Theano
\end{itemize}

В данном проекте для обучения сверточной нейронной сети, которая применялась для распознавания рукописных цифр, был выбран модуль Keras, так как он является функциональным, легким и поддерживает возможности TensorFlow.

\section{Работа с изображениями}

\subsection{PIL}
PIL (Python Imaging Library) предоставляет Python широкий спектр возможностей по работе с изображениями: повороты, изменения размера и другие полезные функции. Библиотека станет хорошим фундаментом для общей обработки и предобработки изображений, например, преобразование цветового пространства и фильтрация с набором встроенных ядер свертки.

\subsection{OpenCV}
OpenCV – библиотека компьютерного зрения, обладающая обширными возможностями, связанными с машинным обучением и распознаванием образов. Была разработана в корпорации Intel в 1999 году.

Использует множество языков программирования, например C++, Python, Java и др. В данный момент в разработке интерфейсы операций с высокой скоростью при помощи CUDA и OpenCL.

OpenCV-Python имеет Numpy, как встроенную библиотеку, которая представляет собой высокоскоростной инструментарий для числовых операций и работы с массивами.

OpenCV-Python - это API Python для OpenCV, сочетающий в себе лучшие качества API OpenCV C++ и языка Python. Использование Numpy делает проще работу с другими библиотеками, работающими с ним, такими как SciPy и Matplotlib.

\chapter{Практическая часть}

\section{Поворот картинки}
Первая задача, которую нужно решить при обработке фотографии – это выявление и устранение наклона таблицы. Для этого используется метод суммирования строк.

Фотография – это двумерный массив, хранящий описание пикселей. При решении проблемы поворота мы работаем с уже преобразованным к бинарной форме изображением, следовательно, каждый пиксель может принимать значение 0 или 1. Мы можем суммировать значения в каждой строке и получить одномерный массив со значениями “насыщенности цвета” для каждой строки. Данный массив в коде программы сохраняется в переменную histogram.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.45]{поворот 1.PNG}
    \includegraphics[scale=0.45]{поворот 2.PNG}
    \caption{Фотография с наклоном и без наклона}
\end{figure}

 Далее, нужно определить дельту между максимальным и минимальным значениями в массиве. Чтобы определить угол, на который повернута таблица, перебираем углы от 0 до 360 с определенным шагом и запоминаем угол с максимальной дельтой. Это и будет угол, на который повернуто наше изображение.

\begin{lstlisting}
    score = np.sum((histogram[1:] - histogram[:-1]) ** 2, dtype=float)
    best_angle = angles[scores.index(max(scores))]
\end{lstlisting}

Для поворота изображения в библиотеке OpenCV существуют функции getRotationMatrix(center, angle, scale) и warpAffine(img, M, size, …).

\begin{lstlisting}
    M = getRotationMatrix(center, angle, scale)
\end{lstlisting}
center – центр изображения\\
angle – угол, на который изображение должно быть повернуто\\
scale – множитель увеличения/уменьшения размера изображения\\
M – матрица преобразования, применяемая к изображению

\begin{lstlisting}
    img = warpAffine(img_init, M, size, …)
\end{lstlisting}
img\_init – исходное изображение\\
M – матрица преобразования\\
size – размер полученного изображения\\
img – преобразованное изображение

С помощью этих функций:
\begin{enumerate}
    \item Находим матрицу преобразования
    \item Считаем размер изображения после поворота, чтобы избежать обрезания краев
    \item Применяем афинное преобразование к фотографии, чтобы развернуть ее в правильное положение
\end{enumerate}

Таким образом, фотография готова для дальнейшего считывания таблицы.

\section{Основной алгоритм (OpenCV + PyTesseract)}

Алгоритм решения задачи делится на два ключевых этапа:
\begin{enumerate}
    \item Разбиение таблицы на ячейки
    \item Распознавание содержимого каждой ячейки
\end{enumerate}

И первый пункт является самым объёмным, из-за универсального подхода к распознанию структуры таблицы и нужды предусматривать различные исключения на каждом этапе.

Основные функции, применяемые в программе (main.py) хранятся в модуле package.py

Первым делом считываем фото и производим предобработку исходной картинки для более точного распознавания -> reading\_photo(…):

\begin{enumerate}
    \item Считываем фото из файла -> cv2.imread(…)
    \item Поворот картинки с помощью функции rotate\_to\_correct(…) по алгоритму описанному выше
    \item Увеличивается размер фото минимум до 600 пикселей в высоту %\rightarrow cv2.resize(…)
    \item Сводим фото к оттенкам серого
    \item Размываем фото -> cv2.erode(…)
    \item Избавляемся от шумов, сведением фото к двум цветам - чёрному(фон) и белому(текст) -> cv2.adaptiveThreshold(…)
\end{enumerate}

\pagebreak
\subsection*{Разбиение таблицы на ячейки:}
\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.8]{разбиение таблицы.png}
    \caption{Исходная таблица}
    \label{fig:my_label}
\end{figure}

1. Распознание вертикальных линий, формирующих таблицу\\ -> vertical\_lines\_detection(…).

Основой для выполнения конкретной задачи является функция, которая распознаёт на фото прямоугольники с размером ядра, задающим вертикальную линию - минимальная ширина по оси Х.
\begin{lstlisting}
    cv2.getStructuringElement(cv2.MORPH_RECT, (1, kernel_len))
\end{lstlisting}

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.8]{вертикальные линии.png}
    \caption{Вертикальные линии}
    \label{fig:my_label}
\end{figure}

2.	Распознание горизонтальных линий, формирующих таблицу\\ -> horizontal\_lines\_detection(...).

\pagebreak
Данная часть выполняется аналогично функцией, которая распознаёт на фото прямоугольники с размером ядра, задающим горизонтальную линию - минимальная ширина по оси У.
\begin{lstlisting}
    cv2.getStructuringElement(cv2.MORPH\_RECT, (kernel\_len, 1))
\end{lstlisting}

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.8]{горизонтальные линии.png}
    \caption{горизонтальные линии}
    \label{fig:my_label}
\end{figure}

3. Объединение горизонталей и вертикалей, для формирования цельной таблицы без содержимого -> combining\_horizontals\_and\_verticals(...).

Применяем функцию, которая наложит полученные ранее фото вертикальных и горизонтальных линий в равном соотношении прозрачности.
\begin{lstlisting}
    cv2.addWeighted(vertical\_lines, 0.5, horizontal\_lines, 0.5, 0.0)
\end{lstlisting}

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.7]{совмещенные линии.png}
    \caption{Совмещенные линии}
    \label{fig:my_label}
\end{figure}

4.	Находим контуры таблицы, полученной на предыдущем шаге, таким образом мы получим контуры всех прямоугольников таблицы - наши будующие ячейки -> cv2.findContours(...).

Используем режим группировки CV\_RETR\_TREE — группирует контуры в многоуровневую иерархию и метод упаковки CV\_CHAIN\_APPROX\_SIMPLE — склеивает все горизонтальные, вертикальные и диагональные контуры.

5.	Сортируем контуры таблицы по порядку их расположения в таблице (сверху вниз) -> sort\_contours(...).

6.	Формируем из контуров список ячеек с рамками -> form\_cells(...).

Данный этап программы можно разделить на подпункты, ведь именно здесь происходит обработка всевозможных исключений, который позволят исключить из списка контуров ненужные - те, которые были выявлены или из-за ошибки программы, или из-за заранее известного фактора:

\begin{enumerate}
\begin{enumerate}
    \item Имея список контуров, переводим их в список прямоугольников задающих координаты ячеек таблицы -> cv2.boundingRect(...), и добавляем в список лишь те, значения ширины и высоты которых не превосходят половины от размеров всего фото - такие ячейки будут представлять из себя контур всей таблицы, а она не является ячейкой таблицы, которую стоит рассматривать 
    \item Удаляем ячейки, которые лежат внутри других - они определенно лишние, такого не должно быть в таблице. Подобное может возникнуть из-за большого разрешения содержимого ячеек, которые могут сами быть приняты за таковые, так как в них могут распознаваться вертикали и горизонтали
    \item Проверяем лежат ли две ячейки в одном столбце и в одной строке - погрешность, из-за черты, которую человек мог провести в какой-то строке. И мы удаляем нижнюю из этих двух, а верхнюю ячейку расширяем, добавляя высоту нижней
\end{enumerate}
\end{enumerate}

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.2]{sells.jpg}
    \caption{Выделение ячеек}
    \label{fig:my_label}
\end{figure}

\pagebreak
7.	Разбиваем список рамок на ячейки по строкам -> rows(...).

До тех пор, пока поле не отличается больше, чем его собственное (высота + среднее значение / 2), поле находится в том же ряду. Как только разница в высоте становится больше текущей (высота + среднее значение /2) мы знаем, что начинается новая строка.

8.	Сортируем строки в каждом столбце (слева направо) -> rows\_sort(...).

\subsection*{Распознавание значений в ячейках -> recognition(...)}

\begin{enumerate}
    \item Рассматриваем циклично содержимое каждой ячейки
    \item Подгоняем содержимое для лучшего распознавания расширением и размыванием -> cv2.dilate(...) & cv2.erode(...)
    \item Анализируем содержимое с помощью технологий компьютерного зрения и формируем список значений на соответствующих позициях -> pytesseract.image\_to\_string(...)
\end{enumerate}

Язык для распознавания содержимого устанавливаем русский: lang='rus'

Также делаем дополнительную обработку ячейки, если её значение пустует. Это может означать, что ячейка содержит единственный символ, который функция pytesseract.image\_to\_string(...) не способна распознать при базовой конфигурации. Поэтому необходимо условие с дополнительным считыванием при следующих параметрах:

lang= 'rus'

config= '--psm 10 --oem 1 -c tessedit\_char\_whitelist=123456789+-'

Последним пунктом, конечно же, является запись матрицы значений в excel файл -> data\_to\_excel(...).

\subsection*{Вспомогательное программное обеспечение}
Программа написана на языке программирования Python с использованием различных его модулей:
\begin{itemize}
    \item Matplotlib.pyplot – модуль для визуализации данных: выводим распознанные горизонтали и вертикали, саму таблицу, ячейки с рамками
    \item NumPy – необходим для упрощения работа со списками данных
    \item Pandas – библиотека применяется для записи таблицы распознанных значений в excel документ
    \item Scipy – модуль применяется в функции поворота картинки
\end{itemize}

\pagebreak
\section{Алгоритм на TensorFlow}
Данный способ считывания таблицы с фотографии представляет собой обучение и использование сверточной нейронной сети с помощью tensorflow и Keras для определения положения и границ таблицы и применение pytesseract для непосредственного извлечения данных из нее.

Основные составляющие программы:
\begin{enumerate}
    \item Подготовка датасета для обучения нейронной сети
    \item Описание модули и ее обучение
    \item Применение модели для распознавания таблиц на фотографиях
\end{enumerate}

\subsection*{Подготовка датасета для обучения сверточной нейронной сети}
Для обучения сверточной нейронной сети, которая должна находить таблицу на фотографии, используется датасет под названием “Marmot Dataset”. Он содержит изображения и их описания в формате xml. 

В каждом описании хранятся:
\begin{enumerate}
    \item координаты и размеры таблицы
    \item координаты и размеры столбцов таблицы
\end{enumerate}

\pagebreak
Пример изображения из датасета:
\begin{figure}[ht]
    %\centering
    \includegraphics[scale=0.5]{Пример изображения из датасета.png}
    \caption{}
    \label{fig:my_label}
\end{figure}

\pagebreak
Пример описания таблицы:
\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.4]{описание таблицы.png}
    \caption{}
    \label{fig:my_label}
\end{figure}

Пример описания столбцов:
\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.4]{описание столбцов.png}
    \caption{}
    \label{fig:my_label}
\end{figure}

На аннотациях к фотографиям с таблицами содержится информация о расположении самой таблицы и о расположении ее столбцов.\\
В аннотациях расположение таблицы закодировано шестнадцатеричным числом, поэтому нам нужно сначала его декодировать с помощью функции hex2double.

\begin{lstlisting}
    def hex2double(hexcode):
\end{lstlisting}
hexcode – шестнадцатеричное число\\
return координаты расположения таблицы

Для определения границ таблицы по описанию из датасета используется функция return\_bboxes\_v1.

\begin{lstlisting}
    def return_bboxes_v1(xml, width, height):
\end{lstlisting}
xml – путь к файлу в формате xml\\
width, height – размеры изображения\\
return bboxes – координаты границ таблицы

Аналогично выглядит функция определения границ столбцов таблицы.
\begin{lstlisting}
    def return_bboxes_extended(xml):
\end{lstlisting}
xml - путь к файлу в формате xml\\
return width, height – размеры изображения\\
bboxes – координаты границ таблицы

Далее, с помощью функции create\_mask создается маска таблицы, на которой показано ее расположение на фотографии, а также маска столбцов. Функция записывает маски изображений в отдельные папки.
\begin{lstlisting}
    def create_mask(img_path, list_of_bboxes, dim, mode='table'):
\end{lstlisting}
img\_path – путь к изображению\\
list\_of\_bboxes – список, хранящий границы таблицы и столбцов таблицы\\
mode – параметр работы функции: создание маски таблицы или ее столбцов\\

\pagebreak
Примеры масок для изображения:
\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.15]{маски таблицы.png}
    \includegraphics[scale=0.15]{маски столбцов.png}
    \caption{Маски таблицы и ее столбцов}
    \label{fig:my_label}
\end{figure}

Теперь изображения, маски и размеры изображений сохраняются в отдельный датафрейм и записываются в csv файл для последующего удобного обращения к ним. Для этого используется функция compute\_masks. Функция записывает и сохраняет csv файл с информацией об изображениях.

\begin{lstlisting}
    def compute_masks(images_dir):
\end{lstlisting}
images\_dir – путь к папке с изображениями

\subsection*{Описание модели и обучение}
Для обучения модели потребуются подготовленные ранее данные. Для этого считываем их из созданного csv файла в переменную train\_df.\\
Создаем tensorflow-датасет для последующей загрузки в модель в переменной dataset.

Для подготовки изображений используется функция \_parse\_function.

\begin{lstlisting}
    def _parse_function(image, mask, colmask):
\end{lstlisting}
image – путь к изображению\\
mask – путь к маске с таблицей\\
colmask – путь к маске со столбцом

Загружает изображения в память, нормализует их, изменяет размер.\\
Возвращает изображения и словарь с масками.

Создаем датасет для передачи модели для обучения, сохраняем его в переменную train\_dataset.\\
Для проектирования и обучения модели машинного обучения используется библиотека TensorFlow.

Для увеличения эффективности модели используется заранее пред обученная модель компьютерного зрения “DenseNet”. Исключение (или dropout) нейронной сети равно 0.6 для избежания переобучения.

Определение слоев нейронной сети задается классами
\begin{lstlisting}
    TableConvLayer(Layer)
    ColumnConvLayer(Layer)
\end{lstlisting}

Создание модели происходит в функции build\_tablenet.
\begin{lstlisting}
    def build_tablenet():
        return model
\end{lstlisting}

Запуск обучения модели:
\begin{lstlisting}
    model.fit(
        train_dataset, epochs=100,
        steps_per_epoch= STEPS_PER_EPOCH,
        validation_data=val_dataset,
        validation_steps= VALIDATION_STEPS,
        callbacks=callbacks
    )
\end{lstlisting}

\subsection*{Применение модели к фотографиям для распознавания таблиц}
Теперь, когда нейронная сеть обучена для распознавания таблиц нужно применить ее на конкретной фотографии.

Для этого загружаем изображение с помощью функции из библиотеки PIL Image.open(image\_filename), нормализуем его, изменяем размер.

С помощью модели получаем маску изображения, на которой показано расположение таблицы:
\begin{lstlisting}
    tab_mask, _ = model.predict(np_image)
\end{lstlisting}

Находим границы прямоугольника по этой маске и вырезаем его по этим координатам на исходном изображении. Таким образом мы вырезали из всей фотографии лишь нужную нам часть – таблицу.
\begin{lstlisting}
    image_orig = image_orig
    x, y, w, h = cv2.boundingRect(tab_mask)
    tab = image_orig.crop((x, y, x + w, y + h))
\end{lstlisting}

Теперь к выделенной части фотографии применяем функцию из библиотеки pytesseract – image\_to\_string(tab), которая считывает текст с изображения и возвращает строку с текстом.

\begin{lstlisting}
    text = pytesseract.image_to_string(tab)
\end{lstlisting}

Для последующей работы с текстом используется функция text\_to\_ecxel. Далее приведено описание ее работы.

\begin{enumerate}
    \item В полученной строке избавляемся от лишних символом в начале и конце. Затем делим ее на несколько строк, соответствующих строкам таблицы с помощью метода split() используя в качестве разделителя \textbackslash n
    \item Каждую полученную строку делим на слова, аналогичным образом, используя в качестве разделителя пробел
    \item Зная общую структуру протокола, мы можем записать полученные данные в нужные нам ячейки
    \item Полученное разбиение на ячейки организуем в датафрейм и записываем в excel файл
\end{enumerate}

\chapter{Результаты}

\section{Оценка эффективности каждого подхода реализации программы}
Эффективность работы программы на конкретном фото протокола рассчитывается, как отношение количества правильно считанных ячеек таблицы, к количеству идеально распознанных ячеек в процентах.

В работе представлено два алгоритма решения поставленной задачи:
\begin{enumerate}
    \item Использование OpenCV для считывания структуры таблицы и PyTesseract для считывания данных
    \item Использование нейронной сети, обученной с помощью TensorFlow и Keras и считывание данных с помощью PyTesseract
\end{enumerate}

Применив эти алгоритмы к тестовым фотографиям, мы получили следующие результаты.

\subsection{OpenCV + PyTesseract}

\subsubsection{Эффективность работы с печатными данными:}
0 - Всевозможные конфигурации параметров функции image\_to\_string() не позволили распознать крестики и нолики (записанные буквами Х и О соответственно)
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{OpenCV/opencv.1.0.1.png}
    \caption{Исходник}
    \label{fig:my_label}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{OpenCV/opencv.1.0.2.png}
    \caption{Результат}
    \label{fig:my_label}
\end{figure}
\pagebreak

1 - эффективность 100\% - вместо крестиков и ноликов было решено использовать плюсики и минусы, их система способна распознать
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{OpenCV/opencv.1.1.1.png}
    \caption{Исходник}
    \label{fig:my_label}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{OpenCV/opencv.1.1.2.png}
    \caption{Результат}
    \label{fig:my_label}
\end{figure}
\pagebreak

2 - эффективность 97.2\% - 3 ячейки считаны неправильно
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{OpenCV/opencv.1.2.1.png}
    \caption{Исходник}
    \label{fig:my_label}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{OpenCV/opencv.1.2.2.png}
    \caption{Результат}
    \label{fig:my_label}
\end{figure}
\pagebreak

\subsubsection{Эффективность работы с данными, введенными с графического планшета:}
1 - эффективность 98.6\% - 2 ячейки не считаны (максимальная эффективность, возможная при рукописном заполнении таблицы - сделано перебором рукописных символов)
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{OpenCV/opencv.2.1.1.png}
    \caption{Исходник}
    \label{fig:my_label}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{OpenCV/opencv.2.1.2.png}
    \caption{Результат}
    \label{fig:my_label}
\end{figure}
\pagebreak

2 - эффективность 62.9\% - 2 ячейки не считаны (не улучшалось содержимое до хороших показателей эффективности)
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{OpenCV/opencv.2.2.1.png}
    \caption{Исходник}
    \label{fig:my_label}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{OpenCV/opencv.2.2.2.png}
    \caption{Результат}
    \label{fig:my_label}
\end{figure}
\pagebreak

\subsubsection{Эффективность работы с данными, заполненными от руки:}

1 -  эффективность 57\%
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{OpenCV/opencv.3.1.1.png}
    \caption{Исходник}
    \label{fig:my_label}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{OpenCV/opencv.3.1.2.png}
    \caption{Результат}
    \label{fig:my_label}
\end{figure}

\textbf{Вывод:} Программа, написанная с полным опором на модуль OpenCV показала внушительный результат. Она идеально считала структуру, приведенных таблиц и с хорошей эффективностью смогла считать содержимое таблицы. Печатные символы считываются идеально. А рукописные символы, записанные на графическом планшете, считываются немного лучше, чем те, что пишутся ручкой на распечатке с дальнейшим сканированием. Также примечательно то, что рукописи можно довести до такого состояния, чтобы программа могла их считывать почти со стопроцентной эффективностью.
\pagebreak

\subsection{TensorFlow + PyTesseract}

\subsubsection{Эффективность работы с печатными данными:}
0
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{TF/tf.1.0.1.png}
    \caption{Исходник}
    \label{fig:my_label}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{TF/tf.1.0.2.png}
    \caption{Результат}
    \label{fig:my_label}
\end{figure}
\pagebreak

1
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{TF/tf.1.1.1.png}
    \caption{Исходник}
    \label{fig:my_label}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{TF/tf.1.1.2.png}
    \caption{Результат}
    \label{fig:my_label}
\end{figure}
\pagebreak

2
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{TF/tf.1.2.1.png}
    \caption{Исходник}
    \label{fig:my_label}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{TF/tf.1.2.2.png}
    \caption{Результат}
    \label{fig:my_label}
\end{figure}
\pagebreak

\subsubsection{Эффективность работы с данными, введенными с графического планшета:}
1
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{TF/tf.2.1.1.png}
    \caption{Исходник}
    \label{fig:my_label}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{TF/tf.2.1.2.png}
    \caption{Результат}
    \label{fig:my_label}
\end{figure}
\pagebreak

2
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{TF/tf.2.2.1.png}
    \caption{Исходник}
    \label{fig:my_label}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{TF/tf.2.2.2.png}
    \caption{Результат}
    \label{fig:my_label}
\end{figure}
\pagebreak

\subsubsection{Эффективность работы с данными, заполненными от руки:}
1
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{TF/tf.3.1.1.png}
    \caption{Исходник}
    \label{fig:my_label}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{TF/tf.3.1.2.png}
    \caption{Результат}
    \label{fig:my_label}
\end{figure}

\textbf{Вывод:} При обработке изображений с помощью алгоритма на Keras/TensorFlow теряется структура изображения и нет смысла говорить об эффективности. Данные, заполненные от руки не считались ни в одном случае.
\pagebreak

\section{Итоги}
Сравнив результаты работы двух способов решения, поставленной перед нами задачи, можно понять, что алгоритм на OpenCV уже очень хорошо справляется со своей задачей. Однако алгоритм, реализованный через TensorFlow, нуждается в доработке, поэтому он уступает первому.

Были получены следующие результаты:
\begin{itemize}
  \item Разработан алгоритм распознавания с использованием OpenCV + PyTesseract
  \item Разработан алгоритм распознавания с использованием Keras/TensorFlow + PyTesseract
  \item Проведено сопоставление эффективности работы двух алгоритмов на основе разных инструментов
  \item Определены наилучшие методологии работы распознавания на основе используемых инструментов
\end{itemize}

\section{Будущее проекта}
Приведённые в проекте программы имеет внушительные перспективы по доработке и улучшению качества точности распознавания:
\begin{itemize}
  \item Доработка алгоритма детекции разметки таблицы при помощи технологий OpenCV:
  \begin{itemize} 
  \item Улучшить способ считывания некачественных фотографий протоколов. Например, если фото имеет большое количество помех: тени и грязная бумага
  \item Научить программу достраивать таблицу при отсутствии на фото её кусочков, например, уголка или границ таблицы
  \item Создание возможность для считывания таблиц любых типов, например, если имеются ячейки, растянутые на несколько столбцов
  \end{itemize}
  
  \item Проектирование собственной нейронной сети, обученной на специализированном датасете в качестве замены PyTesseract, что должно значительно улучшить распознавание рукописных символов, особенно специальных, вроде крестика и нолика
  \item При глубинном изучении возможностей такого крупного пакета, как TensorFlow, возможно значительное улучшение работы программы при кардинальной её доработке и составлении новых тренировочных данных для модели распознавания таблиц
\end{itemize}

\section{Примечания}
Ссылка на репозиторий проекта: \url{https://github.com/Alex-Karma/ML_Project}

\end{document}
